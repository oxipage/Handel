<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=us-ascii">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./handel_methodology_files/filelist.xml">
<link rel=Edit-Time-Data href="./handel_methodology_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title> Ian Page - My Home Page </title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Page</o:Author>
  <o:LastAuthor>Page</o:LastAuthor>
  <o:Revision>26</o:Revision>
  <o:TotalTime>1834</o:TotalTime>
  <o:Created>2001-10-18T01:54:00Z</o:Created>
  <o:LastSaved>2003-08-20T21:33:00Z</o:LastSaved>
  <o:Pages>2</o:Pages>
  <o:Words>1251</o:Words>
  <o:Characters>7133</o:Characters>
  <o:Company>Celoxica</o:Company>
  <o:Lines>59</o:Lines>
  <o:Paragraphs>14</o:Paragraphs>
  <o:CharactersWithSpaces>8759</o:CharactersWithSpaces>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
h1
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	color:black;
	mso-font-kerning:16.0pt;
	font-weight:bold;}
h3
	{margin-right:0cm;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	mso-outline-level:3;
	font-size:13.5pt;
	font-family:"Times New Roman";
	color:black;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:#8F00FF;
	text-decoration:underline;
	text-underline:single;}
p
	{margin-right:0cm;
	mso-margin-top-alt:auto;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
@list l0
	{mso-list-id:793905080;
	mso-list-type:hybrid;
	mso-list-template-ids:-1163369816 67698695 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F071;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:8.0pt;
	font-family:Wingdings;}
@list l1
	{mso-list-id:868683928;
	mso-list-type:hybrid;
	mso-list-template-ids:-1389096938 67698695 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l1:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F071;
	mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;
	mso-ansi-font-size:8.0pt;
	font-family:Wingdings;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="1027">
  <o:colormenu v:ext="edit" fillcolor="#cff"/>
 </o:shapedefaults></xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body bgcolor="#ccffff" lang=EN-GB link=blue vlink="#8f00ff" style='tab-interval:
36.0pt' rgb="#000000">

<div class=Section1>

<h1 align=center style='text-align:center'>The &#8216;Handel&#8217; Methodology</h1>

<h3><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></h3>

<h3>Exploring the Problem</h3>

<p>A major goal of my research work has been to find ways to allow designers
with only programming skills still to design algorithms in hardware. Following
Moore&#8217;s Law, the size of hardware designs is doubling every 18 months. However
there has not been a commensurate increase in the number of hardware designers
available, or the design timescales available to them, or even the productivity
of hardware design tools. I believe that the only way of squaring this
problematic circle is to raise the level of design abstraction. Only by
reducing the amount of hardware detail in a design can the productivity of the
hardware designer be increased. Only by removing it entirely can software
designer&#8217;s skills be deployed in designing hardware.</p>

<p>Given that the goal is to compile programs into hardware, there are some
serious problems to be solved. There are also some approaches to be discarded
that don&#8217;t meet expectations. We make much reference to the C programming
language. This is because it is an extremely common programming language and as
such is a suitable basis (after certain modifications) as a source language for
compiling into hardware. We explore these issues in the following paragraphs.</p>

<h3><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></h3>

<h3>Using a Programming Language as a Hardware Description Language</h3>

<p>One approach to be considered, and discarded quickly, is to use a
conventional programming language as a hardware description language. A popular
example of this approach is to add a hardware class library to C++. Other
approaches add hardware-descriptive features to the language itself.<span
style="mso-spacerun: yes">&nbsp; </span>This may well be a useful solution if
what is needed is a hardware description language. However it doesn&#8217;t fit our
requirements at all. What we want is to describe functionality and algorithms
in the language, not to describe hardware. Only this way can we get the
productivity of software design and allow participation for software and
algorithm experts. Hardware description languages are only usable by hardware
engineers and are at too low a level of abstraction to cope with massively
complex designs.</p>

<h3><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></h3>

<h3>Compiling &#8216;C&#8217; Directly to Hardware</h3>

<p>So, why not choose a popular programming language such as C or C++ and
compile it directly to hardware. This would be great if it were possible. The
problem is that most programming languages are inherently sequential and it is
necessary that the hardware implementation is highly parallel.<span
style="mso-spacerun: yes">&nbsp; </span>Indeed if the hardware implementation
worked sequentially it would probably be no faster than software running on a
processor and the major advantage of hardware implementation would not be
realised. It is possible for a smart compiler to extract a great deal of parallelism
from most sequential programs. The problem is that there is too much
parallelism available, and extracting exactly the optimum parallel
implementation is still an unsolved research topic. Until this (very hard)
optimisation problem is solved, the best that we can do is to build a compiler
which typically only works well for small examples. Even worse is that such a
compiler is not a reliable tool. When it fails or performs poorly on a
particular example, the designer has no useful control over the compilation
process and so is blocked from making progress with the design. What seemed
like a productivity enhancing tool, actually turns out to be productivity
reducing.</p>

<p>So, if we don&#8217;t know how to build a compiler that discovers the right degree
of parallelism in the general case, then where can this parallelism be found? I
believe there is only one reasonable source, and that is the designer. Rather
than us failing to build a compiler that always finds the right degree of
parallelism, instead we require the designer to work a bit harder and define
the parallelism in the program. To do this requires a language that has
expressive power for parallelism. For such a language, building the compiler
becomes a relatively simple task, rather than an impossible one.</p>

<h3><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></h3>

<h3>Compiling a Parallel Language to Hardware</h3>

<p>There are existing languages that have parallel constructs that allow
software to express parallelism so that it can be translated into hardware
parallelism. Java is perhaps the most popular such language. Unfortunately this
language has a poor model of parallelism and a central commitment to
dynamically allocated memory, both of which are serious problems when compiling
to hardware. A much better source language would be occam, which has an
appropriate model of parallelism and its use of memory is totally determinable
at compile time, both excellent features in this context. The language however
is not well known or supported. However, it and the other parallel languages
suffer from a more serious limitation.</p>

<p>In the same way that we don&#8216;t know how to build a compiler that extracts
appropriate parallel specifications from a program that doesn&#8217;t contain them
already, we also don&#8217;t know how to build a compiler that extracts appropriate
timing specifications from a program that doesn&#8217;t contain them already. The two
most important characteristics of a hardware implementation are its use of
space (parallelism) and time. By asking the designer to indicate parallelism,
we have given him control &#8211; at an abstract level &#8211; over the spatial
characteristics of the implementation. To give him control &#8211; again at an
abstract level &#8211; over time, he needs a language with expressive power for
describing time. Then, with control &#8211; at an appropriately abstract level &#8211; over
both space and time, the designer can discharge the obligations that the
compiler is not capable of doing. </p>

<p>The C language, like all imperative languages, has the assignment statement
as the primary element of progress in a computation. It makes sense for it also
to be at the heart of the model of time. One appropriately simple model of time
is to assert that each assignment statement in a program takes one clock cycle
to execute. This is how time is built into the Handel model.</p>

<p><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h3>The Handel Model of Computation</h3>

<p>The Handel model can be retro-fitted to a number of (imperative) programming
languages and allow them to be used for hardware compilation. Its essential
elements are:</p>

<p style='margin-left:36.0pt;text-indent:-18.0pt;mso-list:l1 level1 lfo2;
tab-stops:list 36.0pt'><![if !supportLists]><span style='font-size:8.0pt;
mso-bidi-font-size:12.0pt;font-family:Wingdings'>q<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>The <b>par construct</b> which allows the designer to
indicate that two or more computations will execute in parallel.</p>

<p style='margin-left:36.0pt;text-indent:-18.0pt;mso-list:l1 level1 lfo2;
tab-stops:list 36.0pt'><![if !supportLists]><span style='font-size:8.0pt;
mso-bidi-font-size:12.0pt;font-family:Wingdings'>q<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>The <b>single clock assignment</b> rule that states
that an assignment statement will always complete in a single clock cycle - and
that nothing but an assignment statement will take any additional clock cycles
to execute.</p>

<p class=MsoNormal>Other useful elements, though not nearly as important, are:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt;mso-list:l0 level1 lfo4;
tab-stops:list 36.0pt'><![if !supportLists]><span style='font-size:8.0pt;
mso-bidi-font-size:12.0pt;font-family:Wingdings'>q<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>The <b>channel</b>, which is an element that connects
two parallel processes and allows them to exchange data.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt;mso-list:l0 level1 lfo4;
tab-stops:list 36.0pt'><![if !supportLists]><span style='font-size:8.0pt;
mso-bidi-font-size:12.0pt;font-family:Wingdings'>q<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><![endif]>A <b>width inference</b> system which allows variables,
channels and expressions to have an arbitrary bit-width associated with them
and that the compiler will determine and set this width whenever the designer
has not set it.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>The channel is a point-to-point, unidirectional,
synchronised and unbuffered communication channel. The channel and the par
construct are similar to the same constructs found in the occam language. The
major difference in Handel, is that the parallelism is always guaranteed to be
true (not pseudo) parallelism, and that the timing model is completely
pervasive. This means that any process that is ready-to-run, actually runs
immediately. There is never even a single clock delay before it starts to
execute. An implication of the rules is that a sending and a receiving process
exchanging data via a channel is equivalent to an assignment statement, so it
too takes exactly one clock cycle to execute.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h3><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></h3>

<h3>Handel-C</h3>

<p class=MsoNormal>Handel-C is the language initially developed throughout the
90&#8217;s in the Hardware Compilation Research Group that I founded at Oxford
University. It is the C language retro-fitted with the Handel model of space
and time. The C language is first stripped of the few features that make it
incompatible with the Handel model, such as side-effecting expressions, which
are essentially assignment statements. The elements listed above are then added
to the language. Of course there is more to it than this, but these are the key
elements in defining the language.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>C was chosen because it is a widely known and accepted
language. While not perfect as a basis for adding the Handel extensions, it was
a good enough basis and its wide use was an overriding consideration in my
choosing it. Handel-C was created in the Oxford group in the early 90&#8217;s and is
now the core of the commercial offering from Celoxica. Handel-C is currently
being used in hundreds of companies and universities throughout the world.</p>

<p class=MsoNormal align=center style='text-align:center'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal align=center style='text-align:center'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>


<div class=MsoNormal align=center style='text-align:center'>

<hr size=2 width="100%" align=center>

</div>


<p class=MsoNormal>Ian Page, June 2002</p>

</div>

</body>

</html>
